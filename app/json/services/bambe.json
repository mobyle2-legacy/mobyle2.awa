{
    "type": "program", 
    "name": "bambe", 
    "version": "4.01", 
    "title": "BAMBE", 
    "description": "<text lang=\"en\">Bayesian Analysis in Molecular Biology and Evolution</text> </description>", 
    "authors": "Simon, Larget</authors>", 
    "references": [
        {
            "value": "EMBOSS: The European Molecular Biology Open Software Suite (2000) Rice,P. Longden,I. and Bleasby, A. Trends in Genetics 16, (6) pp276--277</reference>"
        }, 
        {
            "value": "EMBOSS: The European Molecular Biology Open Software Suite (2000) Rice,P. Longden,I. and Bleasby, A. Trends in Genetics 16, (6) pp276--277</reference>"
        }, 
        {
            "value": "EMBOSS: The European Molecular Biology Open Software Suite (2000) Rice,P. Longden,I. and Bleasby, A. Trends in Genetics 16, (6) pp276--277</reference>"
        }, 
        {
            "value": "EMBOSS: The European Molecular Biology Open Software Suite (2000) Rice,P. Longden,I. and Bleasby, A. Trends in Genetics 16, (6) pp276--277</reference>"
        }, 
        {
            "value": "Larget, B. and D. Simon (1999). Markov chain Monte Carlo algorithms for the Bayesian analysis of phylogenetic trees. Molecular Biology and Evolution 16:750-759.</reference>"
        }, 
        {
            "value": "Simon, D. and B. Larget. 1998. Bayesian analysis in molecular biology and evolution (BAMBE), version 1.01 beta. Department of Mathematics and Computer Science, Duquesne University.</reference>"
        }
    ], 
    "sourcelinks": [
        "http://emboss.sourceforge.net/download", 
        "http://emboss.sourceforge.net/download", 
        "http://emboss.sourceforge.net/download", 
        "http://emboss.sourceforge.net/download", 
        "http://www.stat.wisc.edu/~larget/"
    ], 
    "homepagelinks": [
        "http://emboss.sourceforge.net", 
        "http://emboss.sourceforge.net", 
        "http://emboss.sourceforge.net", 
        "http://emboss.sourceforge.net", 
        "http://www.stat.wisc.edu/~larget/"
    ], 
    "doclinks": [
        "http://bioweb2.pasteur.fr/docs/EMBOSS/abiview.html", 
        "http://emboss.sourceforge.net/docs/themes", 
        "http://bioweb2.pasteur.fr/docs/EMBOSS/antigenic.html", 
        "http://emboss.sourceforge.net/docs/themes", 
        "http://bioweb2.pasteur.fr/docs/EMBOSS/backtranambig.html", 
        "http://emboss.sourceforge.net/docs/themes", 
        "http://bioweb2.pasteur.fr/docs/EMBOSS/backtranseq.html", 
        "http://emboss.sourceforge.net/docs/themes"
    ], 
    "mobyle_cats": [
        "display", 
        "alignment:formatter", 
        "sequence:protein:motifs", 
        "sequence:nucleic:translation", 
        "sequence:protein:composition", 
        "sequence:nucleic:translation", 
        "sequence:protein:composition", 
        "phylogeny:bayesian"
    ], 
    "command": "backtranseq", 
    "inputs": {
        "parameters": {
            "bambe": {
                "ishidden": true, 
                "type": {
                    "datatype_class": "String"
                }, 
                "format": {
                    "perl": "bambe.params\"", 
                    "python": "bambe.params\""
                }
            }, 
            "data_file": {
                "ismandatory": true, 
                "prompt": "Alignment file (data-file)", 
                "type": {
                    "biotype": "DNA", 
                    "datatype_class": "Alignment", 
                    "data_formats": [
                        "CLUSTAL"
                    ]
                }, 
                "format": {
                    "perl": "\"data-file=$value\\\\n\"", 
                    "python": "\"data-file=\"+str(value)+\"\\n\""
                }
            }, 
            "run_options": {
                "name": "run_options", 
                "parameters": {
                    "seed": {
                        "prompt": "Seed for random number generator (seed)", 
                        "type": {
                            "datatype_class": "Integer"
                        }, 
                        "default_value": [
                            "194024933"
                        ], 
                        "format": {
                            "perl": "(defined $value and $value != $vdef) ? \"seed=$value\\\\n\" : \"\"", 
                            "python": "(\"\", \"seed=\"+str(value)+\"\\n\")[value is not None and value!=vdef]"
                        }
                    }, 
                    "cycles": {
                        "prompt": "Number of cycles to run the main algorithm (cycles)", 
                        "type": {
                            "datatype_class": "Integer"
                        }, 
                        "default_value": [
                            "1000"
                        ], 
                        "format": {
                            "perl": "(defined $value and $value != $vdef) ?\"cycles=$value\\\\n\" : \"\"", 
                            "python": "(\"\", \"cycles=\"+str(value)+\"\\n\")[value is not None and value!=vdef]"
                        }
                    }, 
                    "window_interval": {
                        "prompt": "Number of cycles between printing trees to output (window-interval)", 
                        "type": {
                            "datatype_class": "Integer"
                        }, 
                        "default_value": [
                            "200"
                        ], 
                        "format": {
                            "perl": "(defined $value and $value != $vdef) ? \"window-interval=$value\\\\n\" : \"\"", 
                            "python": "(\"\", \"window-interval=\"+str(value)+\"\\n\")[value is not None and value!=vdef]"
                        }, 
                        "comment": "<text lang=\"en\">Also used for updating the window size during burn-in.</text> </comment>"
                    }, 
                    "main_algorithm": {
                        "prompt": "Algorithm to run during production cycles (main-algorithm)", 
                        "type": {
                            "datatype_class": "Choice"
                        }, 
                        "default_value": [
                            "local"
                        ], 
                        "authorized_values": [
                            {
                                "value": "global", 
                                "label": "Global"
                            }, 
                            {
                                "value": "local", 
                                "label": "Local"
                            }
                        ], 
                        "format": {
                            "perl": "(defined $value and $value ne $vdef) ? \"main-algorithm=$value\\\\n\" : \"\"", 
                            "python": "(\"\", \"main-algorithm=\"+str(value)+\"\\n\")[value is not None and value != vdef]"
                        }
                    }, 
                    "burn": {
                        "prompt": "Number of cycles to run the burn algorithm (burn)", 
                        "type": {
                            "datatype_class": "Integer"
                        }, 
                        "default_value": [
                            "1000"
                        ], 
                        "format": {
                            "perl": "(defined $value and $value != $vdef) ? \"burn=$value\\\\n\" : \"\"", 
                            "python": "(\"\", \"burn=\"+str(value)+\"\\n\")[value is not None and value!=vdef]"
                        }, 
                        "comment": "<text lang=\"en\">Parameter values are not updated during burn. User should discard these cycles and the initial cycles of the main algorithm before inference.</text> </comment>"
                    }, 
                    "burn_algorithm": {
                        "prompt": "Algorithm to run during burn (burn-algorithm)", 
                        "type": {
                            "datatype_class": "Choice"
                        }, 
                        "default_value": [
                            "global"
                        ], 
                        "authorized_values": [
                            {
                                "value": "global", 
                                "label": "Global"
                            }, 
                            {
                                "value": "local", 
                                "label": "Local"
                            }
                        ], 
                        "format": {
                            "perl": "(defined $value and $value ne $vdef) ? \"burn-algorithm=$value\\\\n\" : \"\"", 
                            "python": "(\"\",\"burn-algorithm=\"+str(value)+\"\\n\")[value is not None and value!=vdef]"
                        }
                    }, 
                    "use_beta": {
                        "prompt": "Use scaled beta distribution modification of the local algorithm (use-beta)", 
                        "type": {
                            "datatype_class": "Boolean"
                        }, 
                        "precond": {
                            "perl": "$main_algorithm eq \"local\" or $burn_algorithm eq \"local\"", 
                            "python": "main_algorithm == \"local\" or burn_algorithm == \"local\""
                        }, 
                        "default_value": [
                            "0"
                        ], 
                        "format": {
                            "perl": "($value) ? \"use-beta=true\\\\n\" : \"\"", 
                            "python": "(\"\", \"use-beta=true\\n\")[ value ]"
                        }
                    }
                }
            }, 
            "model_options": {
                "name": "model_options", 
                "parameters": {
                    "molecular_clock": {
                        "prompt": "Use a molecular clock (molecular-clock)", 
                        "type": {
                            "datatype_class": "Boolean"
                        }, 
                        "default_value": [
                            "1"
                        ], 
                        "format": {
                            "perl": "($value) ? \"\" :\"molecular-clock=false\\\\n\"", 
                            "python": "(\"molecular-clock=false\\n\", \"\")[ value ]"
                        }
                    }, 
                    "likelihood_model": {
                        "prompt": "Likelihood model (likelihood-model)", 
                        "type": {
                            "datatype_class": "Choice"
                        }, 
                        "default_value": [
                            "HKY85"
                        ], 
                        "authorized_values": [
                            {
                                "value": "HKY85", 
                                "label": "Hasegawa, Kishino, Yano (HKY85)"
                            }, 
                            {
                                "value": "F84", 
                                "label": "Felsenstein's PHYLIP (F84)"
                            }, 
                            {
                                "value": "TN93", 
                                "label": "Tamura-Nei (TN93)"
                            }, 
                            {
                                "value": "GREV", 
                                "label": "Hayley (GREV)"
                            }
                        ], 
                        "format": {
                            "perl": "(defined $value and $value ne $vdef) ? \"likelihood-model=$value\\\\n\" : \"\"", 
                            "python": "(\"\", \"likelihood-model=\"+str(value)+\"\\n\")[value is not None and value!=vdef]"
                        }
                    }, 
                    "category_list": {
                        "prompt": "A valid category list (category-list)", 
                        "type": {
                            "datatype_class": "String"
                        }, 
                        "format": {
                            "perl": "(defined $value) ? \"category-list=$value\\\\n\" :\"\"", 
                            "python": "(\"\", \"category-list=\"+str(value)+\"\\n\" )[value is not None]"
                        }, 
                        "comment": "<text lang=\"en\">Each category has its own set of parameters. Each category is denoted by a positive integer between 1 and 10. A comma-separated list gives the categories of the sites in order, e.g., 1,2,3,1,3 means that the first site is in category 1, the second in 2, the third in 3, the fourth in 1, and the fifth site is in category 3.</text> <text lang=\"en\">A repeat count is indicated by a caret (^). For example, 1^20,2^5,3^2 means that the first twenty sites are in category 1, the next five sites are in 2, and the next two sites are in category 3.</text> <text lang=\"en\">Parentheses may be used to group sites together with a common repeat count, i.e., (1,2)^5 is the same as 1,2,1,2,1,2,1,2,1,2. Repeat counts may be nested, e.g., (1^3,2)^2 is the same as 1,1,1,2,1,1,1,2.</text> <text lang=\"en\">Repetition to the end of the list of sites is indicated by an asterisk (*). For example, 1^5,2* means that the first five sites are in category 1, and all the remaining sites are in category 2. Parentheses may also be used in conjunction with the asterisk, e.g., (1,2)* is the same as 1,2,1,2,1,2,.... The category list may contain at most one asterisk and it must be associated with the last category or group in the list. In other words, an asterisk may appear only at the end of the list.</text> <text lang=\"en\">Examples</text> <text lang=\"en\">1* - all sites are the same category. (default)</text> <text lang=\"en\">(1,2,3)* - all sites are partitioned by codon position.</text> <text lang=\"en\">1^99,2^50,3^9 - the sites are divided over three genes. Each gene has its own set of parameters used by all sites in that gene. The first gene is composed of the first ninety-nine sites, the next by the next fifty sites, and the last by nine sites.</text> </comment>"
                    }, 
                    "single_kappa": {
                        "prompt": "Single kappa (single-kappa)", 
                        "type": {
                            "datatype_class": "Boolean"
                        }, 
                        "default_value": [
                            "0"
                        ], 
                        "format": {
                            "perl": "($value) ? \"single-kappa=true\\\\n\" : \"\"", 
                            "python": "(\"\", \"single-kappa=true\\n\")[ value ]"
                        }, 
                        "comment": "<text lang=\"en\">If true, the same kappa parameter is used for all site categories. If false, there are different values for different site categories. It has no effect if there is only one rate category.</text> </comment>"
                    }, 
                    "initial_kappa": {
                        "prompt": "Comma separated list of positive kappa values for each site category (initial-kappa)", 
                        "type": {
                            "datatype_class": "String"
                        }, 
                        "precond": {
                            "perl": "$likelihood_model eq \"HKY85\" or $likelihood_model eq \"F84\"", 
                            "python": "likelihood_model==\"HKY85\" or likelihood_model==\"F84\""
                        }, 
                        "default_value": [
                            "7.5,2.5,10.75"
                        ], 
                        "format": {
                            "perl": "(defined $value and $value ne $vdef) ? \"initial-kappa=$value\\\\n\" : \"\"", 
                            "python": "(\"\", \"initial-kappa=\"+str(value)+\"\\n\")[value is not None and value!=vdef]"
                        }, 
                        "comment": "<text lang=\"en\">If single-kappa is true, a warning is given if more than one value is specified. The first value will be used. If single-kappa is false, a value must be specified for each category in use.</text> </comment>"
                    }, 
                    "initial_theta": {
                        "prompt": "Comma separated list of positive theta values for each site category (initial-theta)", 
                        "type": {
                            "datatype_class": "String"
                        }, 
                        "default_value": [
                            "1.4,1.0,8.3"
                        ], 
                        "format": {
                            "perl": "(defined $value and $value ne $vdef) ? \"initial-theta=$value\\\\n\" : \"\"", 
                            "python": "(\"\", \"initial-theta=\"+str(value)+\"\\n\")[value is not None and value!=vdef]"
                        }, 
                        "comment": "<text lang=\"en\">The weighted average of these values should be 1, with weights given by the proportion of sites in each site category. (Renormalization is automatic and a warning given if the condition fails.) If there are an equal number of sites in each category, for example, the numbers should average to 1.</text> </comment>"
                    }, 
                    "estimate_pi": {
                        "prompt": "Use empirical relative frequencies (estimate-pi)", 
                        "type": {
                            "datatype_class": "Boolean"
                        }, 
                        "default_value": [
                            "1"
                        ], 
                        "format": {
                            "perl": "($value) ? \"\" : \"estimate-pi=false\\\\n\"", 
                            "python": "(\"estimate-pi=false\\n\",\"\")[ value ]"
                        }, 
                        "comment": "<text lang=\"en\">If true, the initial stationary probabilities for each base in each category are estimated by the relative frequencies with which they appear in the data.</text> </comment>"
                    }, 
                    "initial_pia": {
                        "prompt": "Comma separated list of initial pi value of base A (initial-pia)", 
                        "type": {
                            "datatype_class": "String"
                        }, 
                        "precond": {
                            "perl": "not $estimate_pi", 
                            "python": "not estimate_pi"
                        }, 
                        "default_value": [
                            "0.25,0.25,0.25"
                        ], 
                        "format": {
                            "perl": "(defined $value and $value ne $vdef) ? \"initial-pia=$value\\\\n\" : \"\"", 
                            "python": "(\"\", \"initial-pia=\"+str(value)+\"\\n\")[value is not None and value!=vdef]"
                        }
                    }, 
                    "initial_pig": {
                        "prompt": "Comma separated list of initial pi value of base G (initial-pig)", 
                        "type": {
                            "datatype_class": "String"
                        }, 
                        "precond": {
                            "perl": "not $estimate_pi", 
                            "python": "not estimate_pi"
                        }, 
                        "default_value": [
                            "0.25,0.25,0.25"
                        ], 
                        "format": {
                            "perl": "(defined $value and $value ne $vdef) ? \"initial-pig=$value\\\\n\" : \"\"", 
                            "python": "(\"\", \"initial-pig=\"+str(value)+\"\\n\")[value is not None and value!=vdef]"
                        }
                    }, 
                    "initial_pic": {
                        "prompt": "Comma separated list of initial pi value of base C (initial-pic)", 
                        "type": {
                            "datatype_class": "String"
                        }, 
                        "precond": {
                            "perl": "not $estimate_pi", 
                            "python": "not estimate_pi"
                        }, 
                        "default_value": [
                            "0.25,0.25,0.25"
                        ], 
                        "format": {
                            "perl": "(defined $value and $value ne $vdef) ? \"initial-pic=$value\\\\n\" : \"\"", 
                            "python": "(\"\", \"initial-pic=\"+str(value)+\"\\n\")[value is not None and value!=vdef]"
                        }
                    }, 
                    "initial_pit": {
                        "prompt": "Comma separated list of initial pi value of base T (initial-pit)", 
                        "type": {
                            "datatype_class": "String"
                        }, 
                        "precond": {
                            "perl": "not $estimate_pi", 
                            "python": "not estimate_pi"
                        }, 
                        "default_value": [
                            "0.25,0.25,0.25"
                        ], 
                        "format": {
                            "perl": "(defined $value and $value ne $vdef) ? \"initial-pit=$value\\\\n\" : \"\"", 
                            "python": "(\"\",\"initial-pit=\"+str(value)+\"\\n\")[value is not None and value!=vdef]"
                        }
                    }, 
                    "initial_ttp": {
                        "prompt": "Comma separated list of positive transition/transversion parameter values (TN93 model) (initial-ttp)", 
                        "type": {
                            "datatype_class": "String"
                        }, 
                        "precond": {
                            "perl": "$likelihood_model eq \"TN93\"", 
                            "python": "likelihood_model  == \"TN93\""
                        }, 
                        "default_value": [
                            "1.0,1.0,1.0"
                        ], 
                        "format": {
                            "perl": "(defined $value and $value ne $vdef) ? \"initial-ttp=$value\\\\n\" : \"\"", 
                            "python": "(\"\", \"initial-ttp=\"+str(value)+\"\\n\")[value is not None and value!=vdef]"
                        }, 
                        "comment": "<text lang=\"en\">This is used only with TN93. There must be a value specified for each site-category used if TN93 is the chosen model.</text> </comment>"
                    }, 
                    "initial_gamma": {
                        "prompt": "Comma separated list of positive gamma values (TN93 model) (initial-gamma)", 
                        "type": {
                            "datatype_class": "String"
                        }, 
                        "precond": {
                            "perl": "$likelihood_model eq \"TN93\"", 
                            "python": "likelihood_model  == \"TN93\""
                        }, 
                        "default_value": [
                            "1.0,1.0,1.0"
                        ], 
                        "format": {
                            "perl": "(defined $value and $value ne $vdef) ? \"initial-gamma=$value\\\\n\" : \"\"", 
                            "python": "(\"\", \"initial-gamma=\"+str(value)+\"\\n\")[value is not None and value!=vdef]"
                        }, 
                        "comment": "<text lang=\"en\">This is used only with TN93. There must be a value specified for each site-category used if TN93 is the chosen model.</text> </comment>"
                    }, 
                    "initial_Rac": {
                        "prompt": "Comma separated list of positive r values for AC bases(GREV model) (initial-rac)", 
                        "type": {
                            "datatype_class": "String"
                        }, 
                        "precond": {
                            "perl": "$likelihood_model eq \"GREV\"", 
                            "python": "likelihood_model  == \"GREV\""
                        }, 
                        "default_value": [
                            "1.0,1.0,1.0"
                        ], 
                        "format": {
                            "perl": "(defined $value and $value ne $vdef) ? \"initial-rac=$value\\\\n\" : \"\"", 
                            "python": "(\"\", \"initial-rac=\"+str(value)+\"\\n\")[value is not None and value!=vdef]"
                        }, 
                        "comment": "<text lang=\"en\">This is used only with GREV model. </text> </comment>"
                    }, 
                    "initial_Rag": {
                        "prompt": "Comma separated list of positive r values for AG  (GREV model) (initial-rag)", 
                        "type": {
                            "datatype_class": "String"
                        }, 
                        "precond": {
                            "perl": "$likelihood_model eq \"GREV\"", 
                            "python": "likelihood_model  == \"GREV\""
                        }, 
                        "default_value": [
                            "1.0,1.0,1.0"
                        ], 
                        "format": {
                            "perl": "(defined $value and $value ne $vdef) ? \"initial-rag=$value\\\\n\" : \"\"", 
                            "python": "(\"\", \"initial-rag=\"+str(value)+\"\\n\")[value is not None and value!=vdef]"
                        }, 
                        "comment": "<text lang=\"en\">This is used only with GREV model. </text> </comment>"
                    }, 
                    "initial_Rat": {
                        "prompt": "Comma separated list of positive r values for AT (GREV model) (initial-rat)", 
                        "type": {
                            "datatype_class": "String"
                        }, 
                        "precond": {
                            "perl": "$likelihood_model eq \"GREV\"", 
                            "python": "likelihood_model  == \"GREV\""
                        }, 
                        "default_value": [
                            "1.0,1.0,1.0"
                        ], 
                        "format": {
                            "perl": "(defined $value and $value ne $vdef) ? \"initial-rat=$value\\\\n\" : \"\"", 
                            "python": "(\"\", \"initial-rat=\"+str(value)+\"\\n\")[value is not None and value!=vdef]"
                        }, 
                        "comment": "<text lang=\"en\">This is used only with GREV model. </text> </comment>"
                    }, 
                    "initial_Rcg": {
                        "prompt": "Comma separated list of positive r values for CG (GREV model) (initial-rcg)", 
                        "type": {
                            "datatype_class": "String"
                        }, 
                        "precond": {
                            "perl": "$likelihood_model eq \"GREV\"", 
                            "python": "likelihood_model  == \"GREV\""
                        }, 
                        "default_value": [
                            "1.0,1.0,1.0"
                        ], 
                        "format": {
                            "perl": "(defined $value and $value ne $vdef) ? \"initial-rcg=$value\\\\n\" : \"\"", 
                            "python": "(\"\", \"initial-rcg=\"+str(value)+\"\\n\")[value is not None and value!=vdef]"
                        }, 
                        "comment": "<text lang=\"en\">This is used only with GREV model. </text> </comment>"
                    }, 
                    "initial_Rct": {
                        "prompt": "Comma separated list of positive r values for CT (GREV model) (initial-rct)", 
                        "type": {
                            "datatype_class": "String"
                        }, 
                        "precond": {
                            "perl": "$likelihood_model eq \"GREV\"", 
                            "python": "likelihood_model  == \"GREV\""
                        }, 
                        "default_value": [
                            "1.0,1.0,1.0"
                        ], 
                        "format": {
                            "perl": "(defined $value and $value ne $vdef) ? \"initial-rct=$value\\\\n\" : \"\"", 
                            "python": "(\"\", \"initial-rct=\"+str(value)+\"\\n\")[value is not None and value!=vdef]"
                        }, 
                        "comment": "<text lang=\"en\">This is used only with GREV model. </text> </comment>"
                    }, 
                    "initial_Rgt": {
                        "prompt": "Comma separated list of positive r values for GT  (GREV model) (initial-rct)", 
                        "type": {
                            "datatype_class": "String"
                        }, 
                        "precond": {
                            "perl": "$likelihood_model eq \"GREV\"", 
                            "python": "likelihood_model  == \"GREV\""
                        }, 
                        "default_value": [
                            "1.0,1.0,1.0"
                        ], 
                        "format": {
                            "perl": "(defined $value and $value ne $vdef) ? \"initial-rgt=$value\\\\n\" : \"\"", 
                            "python": "(\"\", \"initial-rgt=\"+str(value)+\"\\n\")[value is not None and value!=vdef]"
                        }, 
                        "comment": "<text lang=\"en\">This is used only with GREV model. </text> </comment>"
                    }
                }
            }, 
            "param_update": {
                "name": "param_update", 
                "parameters": {
                    "parameter_update_interval": {
                        "prompt": "Parameter update interval (parameter-update-interval)", 
                        "type": {
                            "datatype_class": "Integer"
                        }, 
                        "default_value": [
                            "1"
                        ], 
                        "format": {
                            "perl": "(defined $value and $value != $vdef) ? \"parameter-update-interval=$value\\\\n\" : \"\"", 
                            "python": "(\"\", \"parameter-update-interval=\"+str(value)+\"\\n\")[value is not None and value!=vdef]"
                        }, 
                        "comment": "<text lang=\"en\">During the main algorithm, any 'on' parameters are updated at each cycle divisible by this value. Use zero for no parameter updating.</text> </comment>"
                    }, 
                    "update_kappa": {
                        "prompt": "Update kappa value (update-kappa)", 
                        "type": {
                            "datatype_class": "Boolean"
                        }, 
                        "precond": {
                            "perl": "$likelihood_model eq \"HKY85\" or $likelihood_model eq \"F84\"", 
                            "python": "likelihood_model==\"HKY85\" or likelihood_model==\"F84\""
                        }, 
                        "default_value": [
                            "1"
                        ], 
                        "format": {
                            "perl": "($value) ? \"\" : \"update-kappa=false\\\\n\"", 
                            "python": "(\"update-kappa=false\\n\", \"\")[ value ]"
                        }
                    }, 
                    "update_theta": {
                        "prompt": "Update theta value (update-theta)", 
                        "type": {
                            "datatype_class": "Boolean"
                        }, 
                        "default_value": [
                            "1"
                        ], 
                        "format": {
                            "perl": "($value) ? \"\" : \"update-theta=false\\\\n\"", 
                            "python": "(\"update-theta=false\\n\", \"\")[ value ]"
                        }
                    }, 
                    "update_pi": {
                        "prompt": "Update pi value (update-pi)", 
                        "type": {
                            "datatype_class": "Boolean"
                        }, 
                        "default_value": [
                            "1"
                        ], 
                        "format": {
                            "perl": "($value) ? \"\" : \"update-pi=false\\\\n\"", 
                            "python": "(\"update-pi=false\\n\", \"\")[ value ]"
                        }
                    }, 
                    "update_ttp": {
                        "prompt": "Update ttp value (TN93 model) (update-ttp)", 
                        "type": {
                            "datatype_class": "Boolean"
                        }, 
                        "precond": {
                            "perl": "$likelihood_model eq \"TN93\"", 
                            "python": "likelihood_model == \"TN93\""
                        }, 
                        "default_value": [
                            "1"
                        ], 
                        "format": {
                            "perl": "($value) ? \"\" : \"update-ttp=false\\\\n\"", 
                            "python": "(\"update-ttp=false\\n\", \"\")[ value ]"
                        }
                    }, 
                    "update_gamma": {
                        "prompt": "Update gamma value for (TN93 model) (update-gamma)", 
                        "type": {
                            "datatype_class": "Boolean"
                        }, 
                        "precond": {
                            "perl": "$likelihood_model eq \"TN93\"", 
                            "python": "likelihood_model == \"TN93\""
                        }, 
                        "default_value": [
                            "1"
                        ], 
                        "format": {
                            "perl": "($value) ? \"\" : \"update-gamma=false\\\\n\"", 
                            "python": "(\"update-gamma=false\\n\", \"\")[ value ]"
                        }
                    }, 
                    "update_grev": {
                        "prompt": "Update grev (GREV model) (update-grev)", 
                        "type": {
                            "datatype_class": "Boolean"
                        }, 
                        "precond": {
                            "perl": "$likelihood_model eq \"GREV\"", 
                            "python": "likelihood_model == \"GREV\""
                        }, 
                        "default_value": [
                            "1"
                        ], 
                        "format": {
                            "perl": "($value) ? \"\" : \"update-grev=false\\\\n\"", 
                            "python": "(\"update-grev=false\\n\", \"\")[ value ]"
                        }
                    }, 
                    "update_invariant_prob": {
                        "prompt": "Update invariant probability (update-invariant-prob)", 
                        "type": {
                            "datatype_class": "Boolean"
                        }, 
                        "default_value": [
                            "0"
                        ], 
                        "format": {
                            "perl": "($value) ? \"update-invariant-prob=true\\\\n\" : \"\"", 
                            "python": "(\"\", \"update-invariant-prob=true\\n\")[ value ]"
                        }
                    }, 
                    "local_tune": {
                        "prompt": "Stretch parameter for local (local-tune)", 
                        "type": {
                            "datatype_class": "Float"
                        }, 
                        "precond": {
                            "perl": "$burn_algorithm eq \"local\" or $main_algorithm eq \"local\"", 
                            "python": "burn_algorithm == \"local\" or main_algorithm == \"local\""
                        }, 
                        "default_value": [
                            "0.19"
                        ], 
                        "format": {
                            "perl": "(defined $value and $value != $vdef) ? \"local-tune=$value\\\\n\" : \"\"", 
                            "python": "(\"\", \"local-tune=\"+str(value)+\"\\n\")[value is not None and value!=vdef]"
                        }, 
                        "comment": "<text lang=\"en\">This tuning parameter is only used with the local algorithm. It modulates the size of a maximal stretch. The smaller the value, the greater the tree acceptance rate will be.</text> </comment>"
                    }, 
                    "theta_tune": {
                        "prompt": "Dirichlet parameter for theta update (theta-tune)", 
                        "type": {
                            "datatype_class": "Float"
                        }, 
                        "precond": {
                            "perl": "$parameter_update_interval != 0 and $update_theta", 
                            "python": "parameter_update_interval != 0 and update_theta"
                        }, 
                        "default_value": [
                            "2000.0"
                        ], 
                        "format": {
                            "perl": "(defined $value and $value != $vdef) ? \"theta-tune=$value\\\\n\" : \"\"", 
                            "python": "(\"\",\"theta-tune=\"+str(value)+\"\\n\")[value is not None and value!=vdef]"
                        }, 
                        "comment": "<text lang=\"en\">Tuning parameter used during update of theta value(s). The larger its value, the more likely proposals are to be accepted.</text> </comment>"
                    }, 
                    "pi_tune": {
                        "prompt": "Dirichlet parameter for pi update (pi-tune)", 
                        "type": {
                            "datatype_class": "Float"
                        }, 
                        "precond": {
                            "perl": "$parameter_update_interval != 0 and $update_pi", 
                            "python": "parameter_update_interval != 0 and update_pi"
                        }, 
                        "default_value": [
                            "2000.0"
                        ], 
                        "format": {
                            "perl": "(defined $value and $value != $vdef) ? \"pi-tune=$value\\\\n\" : \"\"", 
                            "python": "(\"\", \"pi-tune=\"+str(value)+\"\\n\")[value is not None and value!=vdef]"
                        }, 
                        "comment": "<text lang=\"en\">Tuning parameter used during update of pi values. The larger its value, the more likely proposals are to be accepted.</text> </comment>"
                    }, 
                    "kappa_tune": {
                        "prompt": "Halft the size of the window for uniform updates of kappa (kappa-tune)", 
                        "type": {
                            "datatype_class": "Float"
                        }, 
                        "precond": {
                            "perl": "$parameter_update_interval != 0 and $update_kappa and ($likelihood_model eq \"HKY85\" or $likelihood_model eq \"F84\")", 
                            "python": "parameter_update_interval != 0 and update_kappa and (likelihood_model == \"HKY85\" or likelihood_model == \"F84\")"
                        }, 
                        "default_value": [
                            "0.2"
                        ], 
                        "format": {
                            "perl": "(defined $value and $value != $vdef) ? \"kappa-tune=$value\\\\n\" : \"\"", 
                            "python": "(\"\",\"kappa-tune=\"+str(value)+\"\\n\")[value is not None and value!=vdef]"
                        }, 
                        "comment": "<text lang=\"en\">This tuning parameter is only used when 'parameter-update-interval' is positive and 'update-kappa' is true. The smaller its value, the greater the parameter acceptance rate will be.</text> </comment>"
                    }, 
                    "ttp_tune": {
                        "prompt": "Halft window width for ttp update (TN93 model) (ttp-tune)", 
                        "type": {
                            "datatype_class": "Float"
                        }, 
                        "precond": {
                            "perl": "$parameter_update_interval != 0 and $update_ttp and $likelihood_model eq \"TN93\"", 
                            "python": "parameter_update_interval != 0 and update_ttp and likelihood_model == \"TN93\""
                        }, 
                        "default_value": [
                            "0.1"
                        ], 
                        "format": {
                            "perl": "(defined $value and $value != $vdef) ? \"ttp-tune=$value\\\\n\" : \"\"", 
                            "python": "(\"\",\"ttp-tune=\"+str(value)+\"\\n\")[value is not None and value!=vdef]"
                        }, 
                        "comment": "<text lang=\"en\">This tuning parameter is only used when 'parameter-update-interval' is positive and 'update-ttp' is true. The smaller its value, the greater the parameter acceptance rate will be.</text> </comment>"
                    }, 
                    "gamma_tune": {
                        "prompt": "Half window width for gamma update (TN93 model) (gamma-tune)", 
                        "type": {
                            "datatype_class": "Float"
                        }, 
                        "precond": {
                            "perl": "$parameter_update_interval != 0 and $update_gamma and $likelihood_model eq \"TN93\"", 
                            "python": "parameter_update_interval != 0 and update_gamma and likelihood_model == \"TN93\""
                        }, 
                        "default_value": [
                            "0.1"
                        ], 
                        "format": {
                            "perl": "(defined $value and $value != $vdef) ? \"gamma-tune=$value\\\\n\" : \"\"", 
                            "python": "(\"\",\"gamma-tune=\"+str(value)+\"\\n\")[value is not None and value!=vdef]"
                        }, 
                        "comment": "<text lang=\"en\">This tuning parameter is only used when 'parameter-update-interval' is positive and 'update-gamma' is true. The smaller its value, the greater the parameter acceptance rate will be.</text> </comment>"
                    }, 
                    "grev_tune": {
                        "prompt": "Halft window width for grev update (grev-tune)", 
                        "type": {
                            "datatype_class": "Float"
                        }, 
                        "precond": {
                            "perl": "$parameter_update_interval != 0 and $update_grev and $likelihood_model eq \"GREV\"", 
                            "python": "parameter_update_interval != 0 and update_grev and likelihood_model==\"GREV\""
                        }, 
                        "default_value": [
                            "2000"
                        ], 
                        "format": {
                            "perl": "(defined $value and $value != $vdef) ? \"grev-tune=$value\\\\n\" : \"\"", 
                            "python": "(\"\",\"grev-tune=\"+str(value)+\"\\n\")[value is not None and value!=vdef]"
                        }
                    }, 
                    "beta_tune": {
                        "prompt": "Beta parameter for local update (beta-tune)", 
                        "type": {
                            "datatype_class": "Float"
                        }, 
                        "precond": {
                            "perl": "$use_beta", 
                            "python": "use_beta"
                        }, 
                        "default_value": [
                            "10.0"
                        ], 
                        "format": {
                            "perl": "(defined $value and $value != $vdef) ? \"beta-tune=$value\\\\n\" : \"\"", 
                            "python": "(\"\",\"beta-tune=\"+str(value)+\"\\n\")[value is not None and value!=vdef]"
                        }
                    }, 
                    "invariant_prob_tune": {
                        "prompt": "Halft window width for invariant probability update (invariant-prob-tune)", 
                        "type": {
                            "datatype_class": "Float"
                        }, 
                        "precond": {
                            "perl": "$parameter_update_interval != 0 and $update_invariant_prob", 
                            "python": "parameter_update_interval != 0 and update_invariant_prob"
                        }, 
                        "default_value": [
                            "2000"
                        ], 
                        "format": {
                            "perl": "(defined $value and $value != $vdef) ? \"invariant-prob-tune=$value\\\\n\" : \"\"", 
                            "python": "(\"\",\"invariant-prob-tune=\"+str(value)+\"\\n\")[value is not None and value!=vdef]"
                        }
                    }
                }
            }, 
            "output_options": {
                "name": "output_options", 
                "parameters": {
                    "sample_interval": {
                        "prompt": "Sample interval (sample-interval)", 
                        "type": {
                            "datatype_class": "Integer"
                        }, 
                        "default_value": [
                            "200"
                        ], 
                        "format": {
                            "perl": "(defined $value and $value != $vdef) ? \"sample-interval=$value\\\\n\" : \"\"", 
                            "python": "(\"\",\"sample-interval=\"+str(value)+\"\\n\")[value is not None and value!=vdef]"
                        }, 
                        "comment": "<text lang=\"en\">During burn and main algorithms, the tree topology, log likelihoods, and parameters are written to files at each cycle divisible by this value.</text> </comment>"
                    }, 
                    "newick_format": {
                        "prompt": "Newick format of tree file (newick-format)", 
                        "type": {
                            "datatype_class": "Boolean"
                        }, 
                        "default_value": [
                            "1"
                        ], 
                        "format": {
                            "perl": "($value) ? \"newick-format=false\\\\n\" : \"\"", 
                            "python": "(\"newick-format=false\\n\", \"\")[ value ]"
                        }, 
                        "comment": "<text lang=\"en\">Indicates the format of the tree to read (if not random) and the format of the tree to print after the run.</text> </comment>"
                    }
                }
            }, 
            "file_root": {
                "ishidden": true, 
                "type": {
                    "datatype_class": "String"
                }, 
                "format": {
                    "perl": "\"file-root=bambe_results\\\\n\"", 
                    "python": "\"file-root=bambe_results\\n\""
                }
            }, 
            "input_options": {
                "name": "input_options", 
                "parameters": {
                    "outgroup": {
                        "prompt": "Number of the outgroup (outgroup)", 
                        "type": {
                            "datatype_class": "Integer"
                        }, 
                        "precond": {
                            "perl": "$molecular_clock", 
                            "python": "molecular_clock"
                        }, 
                        "default_value": [
                            "1"
                        ], 
                        "format": {
                            "perl": "(defined $value and $value != $vdef) ? \"outgroup=$value\\\\n\" : \"\"", 
                            "python": "(\"\", \"outgroup=\"+str(value)+\"\\n\")[value is not None and value!=vdef]"
                        }, 
                        "comment": "<text lang=\"en\">This is ignored if a molecular clock is assumed. In the absence of a clock, trees and tree topologies are printed with the outgroup emerging directly from the root.</text> </comment>"
                    }, 
                    "tree_file": {
                        "prompt": "Tree file (tree-file)", 
                        "type": {
                            "datatype_class": "Tree", 
                            "data_formats": [
                                "\n            \t", 
                                "\n            \t", 
                                "\n            "
                            ]
                        }, 
                        "precond": {
                            "perl": "$initial_tree_type eq \"bambe\" or $initial_tree_type eq \"newick\"", 
                            "python": "initial_tree_type==\"bambe\" or initial_tree_type==\"newick\""
                        }, 
                        "format": {
                            "perl": "(defined $value) ? \"tree-file=$value\\\\n\" : \"\"", 
                            "python": "(\"\", \"tree-file=\"+str(value)+\"\\n\")[value is not None]"
                        }, 
                        "comment": "<text lang=\"en\">If no tree file is given, the program generates a random tree from a flat distribution where each labeled history is equally likely.</text> </comment>"
                    }, 
                    "initial_tree_type": {
                        "prompt": "Initial tree type (initial-tree-type)", 
                        "type": {
                            "datatype_class": "Choice"
                        }, 
                        "default_value": [
                            "random"
                        ], 
                        "authorized_values": [
                            {
                                "value": "random", 
                                "label": "Random"
                            }, 
                            {
                                "value": "upgma", 
                                "label": "UPGMA"
                            }, 
                            {
                                "value": "neighbor-joining", 
                                "label": "Neighbor-Joining"
                            }, 
                            {
                                "value": "newick", 
                                "label": "Newick"
                            }, 
                            {
                                "value": "bambe", 
                                "label": "Bambe"
                            }
                        ], 
                        "format": {
                            "perl": "(defined $value and $value ne $vdef) ? \"initial-tree-type=$value\\\\n\" : \"\"", 
                            "python": "(\"\", \"initial-tree-type=\"+str(value)+\"\\n\")[value is not None and value != vdef]"
                        }, 
                        "comment": "<text lang=\"en\">. random select a tree from the prior</text> <text lang=\"en\">. upgma sets the initial clock tree to the UPGMA tree using maximum likelihood distances with the specified model and initial parameter values.</text> <text lang=\"en\">. neighbor-joining sets the initial nonclock tree to the neigbor joining tree using maximum likelihood distances with the specified model and initial parameter values.</text> <text lang=\"en\">. newick reads in an initial tree in Newick format from a file.</text> <text lang=\"en\">. bambe reads in an initial tree in BAMBE format from a file.</text> </comment>"
                    }, 
                    "print_all_trees": {
                        "prompt": "Print all trees?(print-all-trees)", 
                        "type": {
                            "datatype_class": "Boolean"
                        }, 
                        "default_value": [
                            "1"
                        ], 
                        "format": {
                            "perl": "($value) ? \"\" : \"print-all-trees=false\\\\n\"", 
                            "python": "(\"print-all-trees=false\\n\", \"\")[value ]"
                        }
                    }, 
                    "max_initial_tree_height": {
                        "prompt": "Initial tree height used to generate an initial random tree (max-initial-tree-height)", 
                        "type": {
                            "datatype_class": "Float"
                        }, 
                        "default_value": [
                            "0.1"
                        ], 
                        "format": {
                            "perl": "(defined $value and $value != $vdef) ? \"max-initial-tree-height=$value\\\\n\" : \"\"", 
                            "python": "(\"\", \"max-initial-tree-height=\"+str(value)+\"\\n\")[value is not None and value!=vdef]"
                        }, 
                        "comment": "<text lang=\"en\">This parameter is only used to generate an initial random tree.</text> </comment>"
                    }
                }
            }
        }
    }, 
    "outputs": {
        "parameters": {
            "results_files": {
                "isout": true, 
                "prompt": "Results files", 
                "type": {
                    "datatype_class": "Text"
                }, 
                "filenames": {
                    "perl": "\"bambe_results.lpd\" and  \"bambe_results.par\" and  \"bambe_results.out\"", 
                    "python": "\"bambe_results.out\""
                }
            }, 
            "result_tree": {
                "isout": true, 
                "prompt": "Tree file", 
                "type": {
                    "datatype_class": "Tree", 
                    "data_formats": [
                        "\n          ", 
                        "\n          ", 
                        "\n        "
                    ]
                }, 
                "filenames": {
                    "perl": "\"bambe_results.tre\"", 
                    "python": "\"bambe_results.tre\""
                }
            }, 
            "top_file": {
                "isout": true, 
                "prompt": "Topology file", 
                "type": {
                    "datatype_class": "Text"
                }, 
                "filenames": {
                    "perl": "\"bambe_results.top\"", 
                    "python": "\"bambe_results.top\""
                }
            }
        }
    }, 
    "comment": "<{http://www.w3.org/1999/xhtml}div >This tool reorders the entries of an MSA according to a reference set of sequences.</{http://www.w3.org/1999/xhtml}div> </comment>"
}