{
    "type": "program", 
    "name": "detect_cnv", 
    "version": "6.3.1", 
    "title": "detect_cnv", 
    "description": "<text lang=\"en\">Copy Number Variation (CNV) detection from signal intensity data (Illumina file)</text> </description>", 
    "authors": "Rice,P. Longden,I. and Bleasby, A.</authors>", 
    "references": [
        {
            "value": "EMBOSS: The European Molecular Biology Open Software Suite (2000) Rice,P. Longden,I. and Bleasby, A. Trends in Genetics 16, (6) pp276--277</reference>"
        }, 
        {
            "value": "EMBOSS: The European Molecular Biology Open Software Suite (2000) Rice,P. Longden,I. and Bleasby, A. Trends in Genetics 16, (6) pp276--277</reference>"
        }, 
        {
            "value": "EMBOSS: The European Molecular Biology Open Software Suite (2000) Rice,P. Longden,I. and Bleasby, A. Trends in Genetics 16, (6) pp276--277</reference>"
        }, 
        {
            "value": "EMBOSS: The European Molecular Biology Open Software Suite (2000) Rice,P. Longden,I. and Bleasby, A. Trends in Genetics 16, (6) pp276--277</reference>"
        }, 
        {
            "value": "Larget, B. and D. Simon (1999). Markov chain Monte Carlo algorithms for the Bayesian analysis of phylogenetic trees. Molecular Biology and Evolution 16:750-759.</reference>"
        }, 
        {
            "value": "Simon, D. and B. Larget. 1998. Bayesian analysis in molecular biology and evolution (BAMBE), version 1.01 beta. Department of Mathematics and Computer Science, Duquesne University.</reference>"
        }, 
        {
            "value": "EMBOSS: The European Molecular Biology Open Software Suite (2000) Rice,P. Longden,I. and Bleasby, A. Trends in Genetics 16, (6) pp276--277</reference>"
        }, 
        {
            "value": "Gascuel O., 1997, BIONJ: an improved version of the NJ algorithm based on a simple model of sequence data, Molecular Biology and Evolution 14(7):685-695</reference>"
        }, 
        {
            "value": "EMBOSS: The European Molecular Biology Open Software Suite (2000) Rice,P. Longden,I. and Bleasby, A. Trends in Genetics 16, (6) pp276--277</reference>"
        }, 
        {
            "value": "Altschul, Stephen F., Thomas L. Madden, Alejandro A. Schaeffer,Jinghui Zhang, Zheng Zhang, Webb Miller, and David J. Lipman (1997), Gapped BLAST and PSI-BLAST: a new generation of protein database search programs, Nucleic Acids Res. 25:3389-3402.</reference>"
        }, 
        {
            "value": "Altschul, Stephen F., Thomas L. Madden, Alejandro A. Schaeffer, Jinghui Zhang, Zheng Zhang, Webb Miller, and David J. Lipman (1997), Gapped BLAST and PSI-BLAST: a new generation of protein database search programs, Nucleic Acids Res. 25:3389-3402.</reference>"
        }, 
        {
            "value": "Criscuolo A, Gribaldo S (2010) BMGE (Block Mapping and Gathering with Entropy): selection of phylogenetic informative regions from multiple sequence alignments. BMC Evolutionary Biology 10:210. </reference>"
        }, 
        {
            "value": "EMBOSS: The European Molecular Biology Open Software Suite (2000) Rice,P. Longden,I. and Bleasby, A. Trends in Genetics 16, (6) pp276--277</reference>"
        }, 
        {
            "value": "EMBOSS: The European Molecular Biology Open Software Suite (2000) Rice,P. Longden,I. and Bleasby, A. Trends in Genetics 16, (6) pp276--277</reference>"
        }, 
        {
            "value": "Huang, X. and Madan, A. (1999) CAP3: A DNA Sequence Assembly Program. Genome Research, 9: 868-877.</reference>"
        }, 
        {
            "value": "EMBOSS: The European Molecular Biology Open Software Suite (2000) Rice,P. Longden,I. and Bleasby, A. Trends in Genetics 16, (6) pp276--277</reference>"
        }, 
        {
            "value": "EMBOSS: The European Molecular Biology Open Software Suite (2000) Rice,P. Longden,I. and Bleasby, A. Trends in Genetics 16, (6) pp276--277</reference>"
        }, 
        {
            "value": "EMBOSS: The European Molecular Biology Open Software Suite (2000) Rice,P. Longden,I. and Bleasby, A. Trends in Genetics 16, (6) pp276--277</reference>"
        }, 
        {
            "value": "EMBOSS: The European Molecular Biology Open Software Suite (2000) Rice,P. Longden,I. and Bleasby, A. Trends in Genetics 16, (6) pp276--277</reference>"
        }, 
        {
            "value": "EMBOSS: The European Molecular Biology Open Software Suite (2000) Rice,P. Longden,I. and Bleasby, A. Trends in Genetics 16, (6) pp276--277</reference>"
        }, 
        {
            "value": "EMBOSS: The European Molecular Biology Open Software Suite (2000) Rice,P. Longden,I. and Bleasby, A. Trends in Genetics 16, (6) pp276--277</reference>"
        }, 
        {
            "value": "EMBOSS: The European Molecular Biology Open Software Suite (2000) Rice,P. Longden,I. and Bleasby, A. Trends in Genetics 16, (6) pp276--277</reference>"
        }, 
        {
            "value": "Christian N. S. Pedersen, Rune B. Lyngso and Jotun Hein. Comparison of coding DNA in Proceedings of the 9th Annual Symposium of Combinatorial Pattern Matching (CPM), 1998.</reference>"
        }, 
        {
            "value": "EMBOSS: The European Molecular Biology Open Software Suite (2000) Rice,P. Longden,I. and Bleasby, A. Trends in Genetics 16, (6) pp276--277</reference>"
        }, 
        {
            "value": "G.Z. Hertz and G.D. Stormo. Identification of consensus patterns in unaligned DNA and protein sequences: a large-deviation statistical basis for penalizing gaps. In: Proceedings of the Third International Conference on Bioinformatics and Genome Research (H.A. Lim, and C.R. Cantor, editors). World Scientific Publishing Co., Ltd. Singapore, 1995. pages 201--216.</reference>"
        }, 
        {
            "value": "EMBOSS: The European Molecular Biology Open Software Suite (2000) Rice,P. Longden,I. and Bleasby, A. Trends in Genetics 16, (6) pp276--277</reference>"
        }, 
        {
            "value": "EMBOSS: The European Molecular Biology Open Software Suite (2000) Rice,P. Longden,I. and Bleasby, A. Trends in Genetics 16, (6) pp276--277</reference>"
        }, 
        {
            "value": "EMBOSS: The European Molecular Biology Open Software Suite (2000) Rice,P. Longden,I. and Bleasby, A. Trends in Genetics 16, (6) pp276--277</reference>"
        }, 
        {
            "value": "EMBOSS: The European Molecular Biology Open Software Suite (2000) Rice,P. Longden,I. and Bleasby, A. Trends in Genetics 16, (6) pp276--277</reference>"
        }, 
        {
            "value": "EMBOSS: The European Molecular Biology Open Software Suite (2000) Rice,P. Longden,I. and Bleasby, A. Trends in Genetics 16, (6) pp276--277</reference>"
        }, 
        {
            "value": "EMBOSS: The European Molecular Biology Open Software Suite (2000) Rice,P. Longden,I. and Bleasby, A. Trends in Genetics 16, (6) pp276--277</reference>"
        }, 
        {
            "value": "A.W.M. Dress, G. Fullen, S.W. Perrey, A Divide and Conquer Approach to Multiple Alignment, Proceedings of the Third International Conference on Intelligent Systems for Molecular Biology (ISMB 95), AAAI Press, Menlo Park, CA, USA, 107-113, 1995.</reference>"
        }, 
        {
            "value": "J. Stoye, Multiple Sequence Alignment with the Divide-and-Conquer Method, Gene 211(2), GC45-GC56, 1998. (Gene-COMBIS)</reference>"
        }, 
        {
            "value": "EMBOSS: The European Molecular Biology Open Software Suite (2000) Rice,P. Longden,I. and Bleasby, A. Trends in Genetics 16, (6) pp276--277</reference>"
        }, 
        {
            "value": "EMBOSS: The European Molecular Biology Open Software Suite (2000) Rice,P. Longden,I. and Bleasby, A. Trends in Genetics 16, (6) pp276--277</reference>"
        }, 
        {
            "value": "EMBOSS: The European Molecular Biology Open Software Suite (2000) Rice,P. Longden,I. and Bleasby, A. Trends in Genetics 16, (6) pp276--277</reference>"
        }
    ], 
    "sourcelinks": [
        "http://emboss.sourceforge.net/download", 
        "http://emboss.sourceforge.net/download", 
        "http://emboss.sourceforge.net/download", 
        "http://emboss.sourceforge.net/download", 
        "http://www.stat.wisc.edu/~larget/", 
        "http://emboss.sourceforge.net/download", 
        "http://www.lirmm.fr/~w3ifa/MAAS/BIONJ/", 
        "http://emboss.sourceforge.net/download", 
        "https://projets.pasteur.fr/projects/list_files/blast2usa", 
        "ftp://ftp.pasteur.fr/pub/gensoft/projects/BMGE/", 
        "ftp://www.isrec.isb-sib.ch/pub/software/unix/boxshade/", 
        "http://emboss.sourceforge.net/download", 
        "http://emboss.sourceforge.net/download", 
        "http://seq.cs.iastate.edu/cap3.html", 
        "http://emboss.sourceforge.net/download", 
        "http://emboss.sourceforge.net/download", 
        "http://emboss.sourceforge.net/download", 
        "http://emboss.sourceforge.net/download", 
        "http://emboss.sourceforge.net/download", 
        "http://emboss.sourceforge.net/download", 
        "http://emboss.sourceforge.net/download", 
        "http://sourceforge.net/projects/codonw/files/", 
        "http://www.daimi.au.dk/~ocaprani/ComAlign/programs/", 
        "http://www.daimi.au.dk/~cstorm/combat/", 
        "http://emboss.sourceforge.net/download", 
        "http://gzhertz.home.comcast.net/~gzhertz/CONSENSUS_2004-04-14.TAR.gz", 
        "http://emboss.sourceforge.net/download", 
        "http://emboss.sourceforge.net/download", 
        "http://emboss.sourceforge.net/download", 
        "http://emboss.sourceforge.net/download", 
        "http://emboss.sourceforge.net/download", 
        "http://emboss.sourceforge.net/download", 
        "http://bibiserv.techfak.uni-bielefeld.de/download/tools/dca.html", 
        "http://emboss.sourceforge.net/download", 
        "http://emboss.sourceforge.net/download", 
        "http://emboss.sourceforge.net/download"
    ], 
    "homepagelinks": [
        "http://emboss.sourceforge.net", 
        "http://emboss.sourceforge.net", 
        "http://emboss.sourceforge.net", 
        "http://emboss.sourceforge.net", 
        "http://www.stat.wisc.edu/~larget/", 
        "http://emboss.sourceforge.net", 
        "http://www.lirmm.fr/~w3ifa/MAAS/BIONJ/", 
        "http://emboss.sourceforge.net", 
        "https://projets.pasteur.fr/projects/show/blast2usa", 
        "http://www.ch.embnet.org/software/BOX_form.html", 
        "http://emboss.sourceforge.net", 
        "http://emboss.sourceforge.net", 
        "http://seq.cs.iastate.edu/", 
        "http://emboss.sourceforge.net", 
        "http://emboss.sourceforge.net", 
        "http://emboss.sourceforge.net", 
        "http://emboss.sourceforge.net", 
        "http://emboss.sourceforge.net", 
        "http://emboss.sourceforge.net", 
        "http://emboss.sourceforge.net", 
        "http://codonw.sourceforge.net/", 
        "http://www.daimi.au.dk/~ocaprani/ComAlign/ComAlign.html", 
        "http://www.daimi.au.dk/~cstorm/combat/", 
        "http://emboss.sourceforge.net", 
        "http://gzhertz.home.comcast.net/~gzhertz/", 
        "http://emboss.sourceforge.net", 
        "http://emboss.sourceforge.net", 
        "http://emboss.sourceforge.net", 
        "http://emboss.sourceforge.net", 
        "http://emboss.sourceforge.net", 
        "http://emboss.sourceforge.net", 
        "http://bibiserv.techfak.uni-bielefeld.de/dca/", 
        "http://emboss.sourceforge.net", 
        "http://emboss.sourceforge.net", 
        "http://emboss.sourceforge.net"
    ], 
    "doclinks": [
        "http://bioweb2.pasteur.fr/docs/EMBOSS/abiview.html", 
        "http://emboss.sourceforge.net/docs/themes", 
        "http://bioweb2.pasteur.fr/docs/EMBOSS/antigenic.html", 
        "http://emboss.sourceforge.net/docs/themes", 
        "http://bioweb2.pasteur.fr/docs/EMBOSS/backtranambig.html", 
        "http://emboss.sourceforge.net/docs/themes", 
        "http://bioweb2.pasteur.fr/docs/EMBOSS/backtranseq.html", 
        "http://emboss.sourceforge.net/docs/themes", 
        "http://bioweb2.pasteur.fr/docs/EMBOSS/banana.html", 
        "http://emboss.sourceforge.net/docs/themes", 
        "http://bioweb2.pasteur.fr/docs/EMBOSS/biosed.html", 
        "http://emboss.sourceforge.net/docs/themes", 
        "http://www.ncbi.nlm.nih.gov/books/bv.fcgi?rid=handbook.chapter.ch16", 
        "http://www.ncbi.nlm.nih.gov/Education/BLASTinfo/tut1.html", 
        "http://www.ncbi.nlm.nih.gov/books/bv.fcgi?rid=handbook.chapter.ch16", 
        "http://www.ncbi.nlm.nih.gov/Education/BLASTinfo/tut1.html", 
        "http://bioweb2.pasteur.fr/docs/BMGE/BMGE_doc.pdf", 
        "http://bioweb2.pasteur.fr/docs/EMBOSS/btwisted.html", 
        "http://emboss.sourceforge.net/docs/themes", 
        "http://bioweb2.pasteur.fr/docs/EMBOSS/cai.html", 
        "http://emboss.sourceforge.net/docs/themes", 
        "http://bioweb2.pasteur.fr/docs/EMBOSS/chaos.html", 
        "http://emboss.sourceforge.net/docs/themes", 
        "http://bioweb2.pasteur.fr/docs/EMBOSS/charge.html", 
        "http://emboss.sourceforge.net/docs/themes", 
        "http://bioweb2.pasteur.fr/docs/EMBOSS/checktrans.html", 
        "http://emboss.sourceforge.net/docs/themes", 
        "http://bioweb2.pasteur.fr/docs/EMBOSS/chips.html", 
        "http://emboss.sourceforge.net/docs/themes", 
        "http://bioweb2.pasteur.fr/docs/cif/cif.html", 
        "http://bioweb2.pasteur.fr/docs/cif/compatible_cohesive_ends.txt", 
        "http://bioweb2.pasteur.fr/docs/cif/paillasse_liste.txt", 
        "http://bioweb2.pasteur.fr/docs/EMBOSS/cirdna.html", 
        "http://emboss.sourceforge.net/docs/themes", 
        "http://bioweb2.pasteur.fr/docs/phylip/doc/clique.html", 
        "http://bioweb2.pasteur.fr/docs/EMBOSS/codcmp.html", 
        "http://emboss.sourceforge.net/docs/themes", 
        "http://serpico.rennes.inria.fr/doku.php?id=software:nd-safir:index", 
        "http://serpico.rennes.inria.fr/doku.php?id=software:nd-safir:index", 
        "http://serpico.rennes.inria.fr/doku.php?id=software:nd-safir:index", 
        "http://bioweb2.pasteur.fr/docs/EMBOSS/coderet.html", 
        "http://emboss.sourceforge.net/docs/themes", 
        "http://codonw.sourceforge.net/Readme.html", 
        "http://codonw.sourceforge.net/Tutorial.html", 
        "http://www.daimi.au.dk/~ocaprani/ComAlign/HowTo.html", 
        "http://bioweb2.pasteur.fr/docs/EMBOSS/compseq.html", 
        "http://emboss.sourceforge.net/docs/themes", 
        "http://bioweb2.pasteur.fr/docs/phylip/doc/consense.html", 
        "http://bioweb2.pasteur.fr/docs/EMBOSS/cons.html", 
        "http://emboss.sourceforge.net/docs/themes", 
        "http://bioweb2.pasteur.fr/docs/EMBOSS/cpgplot.html", 
        "http://emboss.sourceforge.net/docs/themes", 
        "http://bioweb2.pasteur.fr/docs/EMBOSS/cpgreport.html", 
        "http://emboss.sourceforge.net/docs/themes", 
        "http://bioweb2.pasteur.fr/docs/EMBOSS/cusp.html", 
        "http://emboss.sourceforge.net/docs/themes", 
        "http://bioweb2.pasteur.fr/docs/EMBOSS/cutseq.html", 
        "http://emboss.sourceforge.net/docs/themes", 
        "http://bioweb2.pasteur.fr/docs/EMBOSS/dan.html", 
        "http://emboss.sourceforge.net/docs/themes", 
        "http://bioweb2.pasteur.fr/docs/EMBOSS/degapseq.html", 
        "http://emboss.sourceforge.net/docs/themes", 
        "http://bioweb2.pasteur.fr/docs/EMBOSS/density.html", 
        "http://emboss.sourceforge.net/docs/themes", 
        "http://bioweb2.pasteur.fr/docs/EMBOSS/descseq.html", 
        "http://emboss.sourceforge.net/docs/themes"
    ], 
    "mobyle_cats": [
        "display", 
        "alignment:formatter", 
        "sequence:protein:motifs", 
        "sequence:nucleic:translation", 
        "sequence:protein:composition", 
        "sequence:nucleic:translation", 
        "sequence:protein:composition", 
        "phylogeny:bayesian", 
        "sequence:nucleic:composition", 
        "sequence:protein:composition", 
        "phylogeny:distance", 
        "sequence:edit", 
        "alignment:pairwise", 
        "database:search:filter", 
        "database:search:homology", 
        "database:search:display", 
        "database:search:filter", 
        "database:search:display", 
        "database:search:homology", 
        "alignment:multiple:information", 
        "alignment:multiple:display", 
        "sequence:nucleic:composition", 
        "sequence:nucleic:codon_usage", 
        "assembly:assembly", 
        "sequence:nucleic:composition", 
        "sequence:protein:composition", 
        "sequence:protein:composition", 
        "sequence:nucleic:codon_usage", 
        "sequence:enzyme:analysis", 
        "sequence:nucleic:restriction", 
        "display:nucleic:restriction", 
        "display", 
        "phylogeny:others", 
        "alignment:multiple", 
        "alignment:multiple", 
        "alignment:multiple", 
        "alignment:multiple", 
        "alignment:multiple", 
        "alignment:multiple", 
        "sequence:nucleic:codon_usage", 
        "Bio-Imaging", 
        "Bio-Imaging", 
        "Bio-Imaging", 
        "sequence:nucleic:edit", 
        "sequence:nucleic:codon_usage", 
        "alignment:multiple", 
        "alignment:pairwise", 
        "sequence:nucleic:composition", 
        "sequence:protein:composition", 
        "sequence:formatter", 
        "phylogeny:tree_analyser", 
        "sequence:protein:pattern", 
        "sequence:nucleic:pattern", 
        "alignment:consensus", 
        "alignment:structure", 
        "structure:indexing", 
        "sequence:nucleic:cpg_islands", 
        "sequence:nucleic:cpg_islands", 
        "sequence:nucleic:codon_usage", 
        "sequence:edit", 
        "sequence:nucleic:composition", 
        "alignment:multiple", 
        "sequence:edit", 
        "sequence:nucleic:composition", 
        "sequence:edit", 
        "genetics:detection"
    ], 
    "command": "kcolumn.pl", 
    "inputs": {
        "parameters": {
            "preprocess": {
                "name": "preprocess", 
                "parameters": {
                    "infile": {
                        "ismandatory": true, 
                        "prompt": "Input  signal intensity file", 
                        "type": {
                            "datatype_class": "SignalIntensity", 
                            "datatype_superclass": "AbstractText"
                        }, 
                        "format": {
                            "perl": "\" $value\"", 
                            "python": "\" \" + str(value)"
                        }, 
                        "comment": "<text lang=\"en\">The input signal intensity file is a text file that contains information for one marker per line, and all fields in each line are tab-delimited</text> <text lang=\"en\">The first line of the file specifies the meaning for each tab-delimited column. For example, there are six fields in each line in the file, corresponding to SNP name, chromosome, position, genotype, Log R Ratio (LRR) and B Allele Frequency (BAF), respectively.</text> <text lang=\"en\">The CNV calling only requires the SNP Name, LRR and BAF values. Note that the relative position of LRR and BAF is different from the previous file; again the header line tells the program that the second column represents BAF values, yet the third column is LRR values.</text> </comment>"
                    }, 
                    "split": {
                        "ismandatory": true, 
                        "prompt": "Number of tab-delimited column (field) per individual genotyping in intensity file", 
                        "type": {
                            "datatype_class": "Integer"
                        }, 
                        "format": {
                            "perl": "\" split $value -heading 3 --name_by_header -tab -out $filename\"", 
                            "python": "\" split \" + str(value) + \" -heading 3 --name_by_header -tab --out \"+ str(infile)"
                        }
                    }
                }
            }, 
            "analyse": {
                "name": "analyse", 
                "parameters": {
                    "type": {
                        "prompt": "Analyse type without cnv calls file", 
                        "type": {
                            "datatype_class": "Choice"
                        }, 
                        "default_value": [
                            "null"
                        ], 
                        "authorized_values": [
                            {
                                "value": "null", 
                                "label": "Choice"
                            }, 
                            {
                                "value": "--test", 
                                "label": "Individual-based CNV calling (test)"
                            }, 
                            {
                                "value": "--joint", 
                                "label": "Joint CNV calls for trio (joint)"
                            }, 
                            {
                                "value": "--validate", 
                                "label": "Validate copy number at a pre-specified region (validate)"
                            }, 
                            {
                                "value": "--summary", 
                                "label": "Summary statistics on signal quality (summary)"
                            }
                        ], 
                        "format": {
                            "perl": " detect_cnv.pl $value \" : \"\"", 
                            "python": " detect_cnv.pl \" + str(value) )[ value is not None and value !=vdef]"
                        }, 
                        "ctrl": {
                            "perl": "(defined $value and not defined $rawcnv) or (not defined $value and defined $rawcnv)", 
                            "python": "(value is not None and rawcnv is None) or (value is None and rawcnv is not None)"
                        }, 
                        "comment": "<text lang=\"en\">--test: test a signal intensity file to generate CNV calls.</text> <text lang=\"en\">--joint: New in July 2008: generate CNV calls for a father-mother-off- spring trio via a one-step procedure. It is considerably slower than the --trio argument, but generates more accurate CNV calls with reduced false negative rates in simulation studies.</text> <text lang=\"en\">--summary: generate summary statistics on signal quality for each input file. Usually the summary is provided when calling CNVs and can be written to a log file via the --log argument; however, some- times users forget to use --log, such that the signal quality information is lost. The --summary argument can calculate the signal quality again quickly without calling CNVs.</text> </comment>"
                    }, 
                    "rawcnv": {
                        "prompt": "Analyse type with cnv calls file", 
                        "type": {
                            "datatype_class": "Choice"
                        }, 
                        "default_value": [
                            "null"
                        ], 
                        "authorized_values": [
                            {
                                "value": "null", 
                                "label": "Choice"
                            }, 
                            {
                                "value": "--trio", 
                                "label": "Trio-based CNV calling (trio)"
                            }, 
                            {
                                "value": "--quartet", 
                                "label": "Posterior CNV calls for quartet (quartet)"
                            }, 
                            {
                                "value": "--cctest", 
                                "label": "Case-control comparison of per-marker CNV frequency (cctest)"
                            }, 
                            {
                                "value": "--exclude_heterosomic", 
                                "label": "Empirically exclude CNVs in heterosomic chromosomes (exclude_heterosomic)"
                            }
                        ], 
                        "format": {
                            "perl": " detect_cnv.pl $value \" : \"\"", 
                            "python": " detect_cnv.pl \" + str(value) )[ value is not None and value !=vdef]"
                        }, 
                        "ctrl": {
                            "perl": "(defined $value and defined $cnvfile and not defined $type) or (not defined $value and defined $type)", 
                            "python": "(value is not None and cnvfile is not None and type is None) or (value is None and type is not None)"
                        }, 
                        "comment": "<text lang=\"en\">--trio: generate CNV calls for a father-mother-offspring trio, given a CNV file containing calls generated on each individual separately, a HMM model file, a PFB file, and the three signal intensity files.</text> <text lang=\"en\">--quartet: jointly generate CNV calls for a father-mother-offspring1-offp- spring2 quartet, given a CNV file containing calls generated on each individual separately, a HMM model file, a PFB file, and the four signal intensity files.</text> <text lang=\"en\"> --cctest: perform a case-control test on the frequency of having CNVs for each marker within CNVs. A separate phenotype file must be specified via the --phenofile argument for this to work. The actual test is a two-sided Fisher exact test. The --onesided argument can be specified for performing one-sided test, and the --type_filter argument can be specified so that only \"dup\" or \"del\" is compared between cases and controls.</text> <text lang=\"en\">--exclude_heterosomic: exclude CNV calls from chromosomes showing evidence of heterosomic abberations from a given file containing CNV calls. An purely empirical method is applied in this procedure, although I recommended always manually examine the patterns of BAF to determine whether heterosomic abberation is present in a particular sample, if the sample size is relatively small (<100).</text> </comment>"
                    }, 
                    "infile_name": {
                        "ishidden": true, 
                        "prompt": "Input file name", 
                        "type": {
                            "datatype_class": "Filename"
                        }, 
                        "precond": {
                            "perl": "$type eq '--test' or $type eq '--joint' or $type eq '--validate' or $type eq '--summary' or $rawcnv eq '--trio' or $rawcnv eq '--quartet' or $rawcnv eq '--cctest' or $rawcnv eq '--exclude_heterosomic'", 
                            "python": "type =='--test' or type =='--joint' or type =='--validate' or type =='--summary' or rawcnv =='--trio' or rawcnv =='--quartet' or rawcnv =='--cctest' or rawcnv =='--exclude_heterosomic'"
                        }, 
                        "format": {
                            "perl": "\" $infile.*\"", 
                            "python": "\" \" + infile + \".*\""
                        }, 
                        "comment": "<text lang=\"en\">Specify an output file prefix.</text> </comment>"
                    }, 
                    "cnvfile": {
                        "prompt": "CNV calls file (cnv)", 
                        "precond": {
                            "perl": "defined $rawcnv", 
                            "python": "rawcnv is not None"
                        }, 
                        "type": {
                            "datatype_class": "Cnv", 
                            "datatype_superclass": "AbstractText"
                        }, 
                        "format": {
                            "perl": "(defined $value) ? \"--cnv $value \" : \"\"", 
                            "python": "( \"\" , \" --cnv \" + str(value) )[ value is not None]"
                        }, 
                        "comment": "<text lang=\"en\">A file containing CNV calls, that could be generated by the -test operation of this program: trio, quartet, exclude_heterosomic, cctest</text> </comment>"
                    }, 
                    "out_cnv_filename": {
                        "ishidden": true, 
                        "prompt": "Output CNV file name", 
                        "type": {
                            "datatype_class": "Filename"
                        }, 
                        "precond": {
                            "perl": "$type eq '--test' and $infile", 
                            "python": "type == '--test' and infile"
                        }, 
                        "format": {
                            "perl": "\" --out $infile_rawcnv\"", 
                            "python": "\" --out \" + infile + \"_rawcnv \""
                        }, 
                        "comment": "<text lang=\"en\">Specify an output file prefix. By default the output filename starts with \"gengen\".</text> </comment>"
                    }, 
                    "hmmmodel": {
                        "ismandatory": true, 
                        "prompt": "HMM model (hmm)", 
                        "type": {
                            "datatype_class": "Choice"
                        }, 
                        "precond": {
                            "perl": "($type is not None or $rawcnv is not None) and ($type and $rawcnv and $rawcnv ne '--cctest' and $rawcnv ne '--exclude_heterosomic'", 
                            "python": "(type is not None or rawcnv is not None) and (type != '--summary' and (rawcnv !='--cctest' and rawcnv !='--exclude_heterosomic'))"
                        }, 
                        "default_value": [
                            "null"
                        ], 
                        "authorized_values": [
                            {
                                "value": "null", 
                                "label": "Choose an HMM model"
                            }, 
                            {
                                "value": "hhall.hmm", 
                                "label": "hhall.hmm"
                            }, 
                            {
                                "value": "hh550.hmm", 
                                "label": "hh550.hmm"
                            }
                        ], 
                        "format": {
                            "perl": "$value \" : \"\"", 
                            "python": "\" + str(value) )[ value is not None]"
                        }, 
                        "comment": "<text lang=\"en\">Specify a HMM model file containing elements necessary for specifying the hidden Markov model for CNV calling: test, validate, joint, trio, quartet</text> </comment>"
                    }, 
                    "pfb": {
                        "ismandatory": true, 
                        "prompt": "Population frequency for B allelel file (pfb)", 
                        "type": {
                            "datatype_class": "Choice"
                        }, 
                        "precond": {
                            "perl": "($type is not None or $rawcnv is not None) and ($rawcnv ne '--exclude_heterosomic')", 
                            "python": "(type is not None or rawcnv is not None) and (rawcnv !='--exclude_heterosomic')"
                        }, 
                        "default_value": [
                            "null"
                        ], 
                        "authorized_values": [
                            {
                                "value": "null", 
                                "label": "Choose an population frequency"
                            }, 
                            {
                                "value": "hhall.hg18.pfb", 
                                "label": "hhall.hg18.pfb"
                            }, 
                            {
                                "value": "hh550.hg18.pfb", 
                                "label": "hh550.hg18.pfb"
                            }, 
                            {
                                "value": "hc12v1.hg18.pfb", 
                                "label": "hc12v1.hg18.pfb"
                            }, 
                            {
                                "value": "ho1v1.hg18.pfb", 
                                "label": "ho1v1.hg18.pfb"
                            }
                        ], 
                        "format": {
                            "perl": "$value \" : \"\"", 
                            "python": "\" + str(value) )[ value is not None]"
                        }, 
                        "comment": "<text lang=\"en\">A population frequency of B allele file containing chromosome coordinates of each SNP, as well as the frequency of B allele in a large reference population for this SNP: test, validate, joint, summary, trio, quartet, cctest</text> </comment>"
                    }, 
                    "gcmodel": {
                        "prompt": "A file containing GC model for wave adjustment (gcmodel)", 
                        "type": {
                            "datatype_class": "Choice"
                        }, 
                        "precond": {
                            "perl": "$type eq '--test' or $rawcnv eq '--trio' or $rawcnv eq '--quartet' or  $type eq '--joint' or  $type eq '--validate'", 
                            "python": "(type == '--test' or type =='--joint' or type =='--validate') or (rawcnv =='--trio' or rawcnv =='--quartet')"
                        }, 
                        "default_value": [
                            "null"
                        ], 
                        "authorized_values": [
                            {
                                "value": "null", 
                                "label": "Choose an GC model"
                            }, 
                            {
                                "value": "hhall.hg18.gcmodel", 
                                "label": "hhall.hg18.gcmodel"
                            }, 
                            {
                                "value": "hh550.hg18.gcmodel", 
                                "label": "hh550.hg18.gcmodel"
                            }, 
                            {
                                "value": "hc12v1.hg18.gcmodel", 
                                "label": "hc12v1.hg18.gcmodel"
                            }, 
                            {
                                "value": "ho1v1.hg18.gcmodel", 
                                "label": "ho1v1.hg18.gcmodel"
                            }
                        ], 
                        "format": {
                            "perl": "$value \" : \"\"", 
                            "python": "\" + str(value) )[ value is not None]"
                        }, 
                        "comment": "<text lang=\"en\">A file that contains the GC percentage in the 1Mb region around each marker for the GC-model based signal adjustment: test, joint, validate, trio, quartet</text> </comment>"
                    }
                }
            }, 
            "cnvoutput": {
                "name": "cnvoutput", 
                "parameters": {
                    "outputformat": {
                        "prompt": "Output format", 
                        "type": {
                            "datatype_class": "Choice"
                        }, 
                        "precond": {
                            "perl": "($type is not None or $rawcnv is not None)", 
                            "python": "(type is not None or rawcnv is not None)"
                        }, 
                        "default_value": [
                            "output"
                        ], 
                        "authorized_values": [
                            {
                                "value": "output", 
                                "label": "Program output format"
                            }, 
                            {
                                "value": "bed", 
                                "label": "BED format"
                            }, 
                            {
                                "value": "tab", 
                                "label": "TAB format"
                            }
                        ], 
                        "format": {
                            "perl": " visualize_cnv.pl --format $value \" : \"\"", 
                            "python": " visualize_cnv.pl --format %s \" % str(value) )[ value is not None and value !=vdef]"
                        }
                    }, 
                    "bed_cnv_infile": {
                        "ishidden": true, 
                        "prompt": "Output file name for visualize_cnv (.rawcnv)", 
                        "type": {
                            "datatype_class": "Filename"
                        }, 
                        "precond": {
                            "perl": "$type eq '--test' and $infile and $outputformat ne 'output'", 
                            "python": "type == '--test' and infile and outputformat != 'output'"
                        }, 
                        "format": {
                            "perl": "\" --out $infile.$outputformatcnv $infile.rawcnv \"", 
                            "python": "\" --out \" + infile + \"_\" + outputformat + \"cnv \" + infile + \"_rawcnv \""
                        }
                    }, 
                    "bed_infile": {
                        "ishidden": true, 
                        "prompt": "Output file name for visualize_cnv (.out)", 
                        "type": {
                            "datatype_class": "Filename"
                        }, 
                        "precond": {
                            "perl": "($type is not None or $rawcnv is not None) and $type eq '--test' and $outputformat ne 'output'", 
                            "python": "(type is not None or rawcnv is not None) and type != '--test' and outputformat != 'output'"
                        }, 
                        "format": {
                            "perl": "\" --out $infile.$outputformat detect_cnv.out \"", 
                            "python": "\" --out \" +  infile + \"_\" + outputformat + \" detect_cnv.out \" "
                        }
                    }
                }
            }, 
            "cnvcontrol": {
                "name": "cnvcontrol", 
                "parameters": {
                    "minsnp": {
                        "prompt": "Minimum number of SNPs within CNV (minsnp)", 
                        "type": {
                            "datatype_class": "Integer"
                        }, 
                        "precond": {
                            "perl": "$type eq '--test' or  $rawcnv eq '--trio' or $rawcnv eq '--quartet' or  $type eq '--joint' or  $type eq '--validate'", 
                            "python": "type =='--test' or rawcnv =='--trio' or rawcnv =='--quartet' or type =='--joint' or type =='--validate'"
                        }, 
                        "default_value": [
                            "3"
                        ], 
                        "format": {
                            "perl": "(defined $value and $value != $vdef) ? \"--minsnp $value \" : \"\"", 
                            "python": "( \"\" , \" --minsnp \" + str(value) )[ value is not None and value != vdef]"
                        }, 
                        "comment": "<text lang=\"en\">The minimum number of SNPs that a CNV call must contain to be in output: test, joint, validate, trio, quartet</text> </comment>"
                    }, 
                    "minlength": {
                        "prompt": "Minimum length of bp within CNV (minlength)", 
                        "type": {
                            "datatype_class": "Integer"
                        }, 
                        "precond": {
                            "perl": "$type eq '--test' or $rawcnv eq '--trio' or $rawcnv eq '--quartet' or $type eq '--joint' or  $type eq '--validate'", 
                            "python": "type =='--test' or rawcnv =='--trio' or rawcnv =='--quartet' or type =='--joint' or type =='--validate'"
                        }, 
                        "format": {
                            "perl": "(defined $value) ? \"--minlength $value \" : \"\"", 
                            "python": "( \"\" , \" --minlength \" + str(value) )[ value is not None ]"
                        }, 
                        "ctrl": {
                            "perl": "$minlength =~ m/^\\d+(k|m)?$/i", 
                            "python": " 0"
                        }, 
                        "comment": "<text lang=\"en\">The minimum length of base pairs that a CNV call must contain to be in output: test, joint, validate, trio, quartet</text> </comment>"
                    }, 
                    "minconf": {
                        "prompt": "Minimum confidence score of CNV (minconf)", 
                        "type": {
                            "datatype_class": "Integer"
                        }, 
                        "precond": {
                            "perl": "$type eq '--test' or  $type eq '--validate'", 
                            "python": "type =='--test' or type =='--validate'"
                        }, 
                        "format": {
                            "perl": "(defined $value) ? \"--minconf $value \" : \"\"", 
                            "python": "( \"\" , \" --minconf \" + str(value) )[ value is not None ]"
                        }, 
                        "comment": "<text lang=\"en\">Minimum confidence score for a CNV call to be in output. This is an experimental feature, and the actual definition of \"confidence score\" may change in the future: test, validate</text> </comment>"
                    }, 
                    "confidence": {
                        "prompt": "Calculate confidence for each CNV (confidence)", 
                        "type": {
                            "datatype_class": "Boolean"
                        }, 
                        "precond": {
                            "perl": "$type eq '--test' or  $type eq '--validate'", 
                            "python": "type =='--test' or type =='--validate'"
                        }, 
                        "default_value": [
                            "0"
                        ], 
                        "format": {
                            "perl": "($value) ? \"--confidence\" : \"\"", 
                            "python": "( \"\" , \" --confidence \" )[ value ]"
                        }, 
                        "comment": "<text lang=\"en\">Calculate a confidence score for each CNV call. This is an experimental feature, and the actual definition of \"confidence score\" may change in the future: test, validate</text> </comment>"
                    }, 
                    "chrx": {
                        "prompt": "Use chromosomeX-specific treatment (chrx)", 
                        "type": {
                            "datatype_class": "Boolean"
                        }, 
                        "precond": {
                            "perl": "$type eq '--test' or  $rawcnv eq '--trio' or  $rawcnv eq '--quartet' or  $type eq '--joint' or  $type eq '--validate'", 
                            "python": "type =='--test' or rawcnv =='--trio' or rawcnv =='--quartet' or type =='--joint' or type =='--validate'"
                        }, 
                        "default_value": [
                            "0"
                        ], 
                        "format": {
                            "perl": "($value) ? \"--chrx\" : \"\"", 
                            "python": "( \"\" , \" --chrx \" )[ value ]"
                        }, 
                        "comment": "<text lang=\"en\">Process chromosome X specifically. By default only autosomes will be processed by this program: test, joint, validate, trio, quartet. </text> </comment>"
                    }, 
                    "sexfile": {
                        "prompt": "Filename and sex (male/female) for chromosomeX (sex)", 
                        "type": {
                            "datatype_class": "Sex", 
                            "datatype_superclass": "AbstractText"
                        }, 
                        "precond": {
                            "perl": "$chrx and not $bafxhet", 
                            "python": "chrx and not bafxhet"
                        }, 
                        "format": {
                            "perl": "(defined $value) ? \"--sex $value \" : \"\"", 
                            "python": "( \"\" , \" --sex \" + str(value) )[ value is not None]"
                        }, 
                        "comment": "<text lang=\"en\">A 2-column file containing filename and sex (male/female) for sex chromosome calling with chromosomeX-specific (chrx) argument. The first tab- delimited column should be the input signal file name, while the second tab-delimited column should be male or female. Alternatively, abbreviations including m (male), f (female), 1 (male) or 2 (female) are also fine.</text> </comment>"
                    }, 
                    "bafxhet": {
                        "prompt": "Minimum BAF heterozygosity rate to predict female gender when file is not supplied (bafxhet)", 
                        "type": {
                            "datatype_class": "Float"
                        }, 
                        "precond": {
                            "perl": "$chrx and not $sexfile", 
                            "python": "chrx and not sexfile"
                        }, 
                        "default_value": [
                            "0.1"
                        ], 
                        "format": {
                            "perl": "(defined $value and $value != $vdef) ? \"--bafxhet $value\" : \"\"", 
                            "python": "( \"\" , \" --bafxhet \" + str(value) )[ value is not None and value != vdef]"
                        }, 
                        "ctrl": {
                            "perl": " 1", 
                            "python": " 1"
                        }, 
                        "comment": "<text lang=\"en\">This argument specifies the BAF heterozygosity rate in chrX to predict the sex for a sample. Note that this rate is based on BAF values so it is not genotype heterozygosity rate and indeed quite different/smaller than that genotype heterozygosity rate. By default if >10% chrX markers have BAF values around 0.5, the sample is predicted as female. This threshold however does not work for Affymetrix genome-wide arrays (instead a 5% threshold is better used). For chrX CNV calling, rather than relying on PennCNV prediction of gender, it is always best to explicitely specify the sample sex using the -sexfile argument.</text> </comment>"
                    }
                }
            }, 
            "validateCalling": {
                "name": "validateCalling", 
                "precond": {
                    "perl": "$type eq '--validate'", 
                    "python": "type == '--validate'"
                }, 
                "parameters": {
                    "startsnp": {
                        "ismandatory": true, 
                        "prompt": "Start SNP of a pre-specified region (startsnp)", 
                        "type": {
                            "datatype_class": "String"
                        }, 
                        "precond": {
                            "perl": "not candlist ", 
                            "python": "not candlist"
                        }, 
                        "format": {
                            "perl": "(defined $value) ? \"--startsnp $value\" : \"\"", 
                            "python": "( \"\" , \" --startsnp \" + str(value) )[ value is not None ]"
                        }, 
                        "comment": "<text lang=\"en\">Specify the start SNP of a pre-specified region used in --validate operation</text> </comment>"
                    }, 
                    "endsnp": {
                        "ismandatory": true, 
                        "prompt": "End SNP of a pre-specified region (endsnp)", 
                        "type": {
                            "datatype_class": "String"
                        }, 
                        "precond": {
                            "perl": "not candlist ", 
                            "python": "not candlist"
                        }, 
                        "format": {
                            "perl": "(defined $value) ? \"--endsnp $value\" : \"\"", 
                            "python": "( \"\" , \" --endsnp \" + str(value) )[ value is not None ]"
                        }, 
                        "comment": "<text lang=\"en\">Specify the end SNP of a pre-specified region used in --validate operation</text> </comment>"
                    }, 
                    "delfreq": {
                        "ismandatory": true, 
                        "prompt": "Prior deletion frequency of a pre-specified region (delfreq)", 
                        "type": {
                            "datatype_class": "Float"
                        }, 
                        "precond": {
                            "perl": "not candlist ", 
                            "python": "not candlist"
                        }, 
                        "format": {
                            "perl": "(defined $value) ? \"--delfreq $value\" : \"\"", 
                            "python": "( \"\" , \" --delfreq \" + str(value) )[ value is not None ]"
                        }, 
                        "ctrl": {
                            "perl": "1", 
                            "python": "=0"
                        }, 
                        "comment": "<text lang=\"en\">Specify the prior deletion allele frequency of a pre-specified region used in --validate operation (this frequency can be estimated from CNV calls by --test operation)</text> </comment>"
                    }, 
                    "dupfreq": {
                        "ismandatory": true, 
                        "prompt": "Prior duplication frequency of a pre-specified region (dupfreq)", 
                        "type": {
                            "datatype_class": "Float"
                        }, 
                        "precond": {
                            "perl": "not candlist", 
                            "python": "not candlist"
                        }, 
                        "format": {
                            "perl": "(defined $value) ? \"--dupfreq $value\" : \"\"", 
                            "python": "( \"\" , \" --dupfreq \" + str(value) )[ value is not None ]"
                        }, 
                        "ctrl": {
                            "perl": "=0", 
                            "python": "=0"
                        }, 
                        "comment": "<text lang=\"en\">Specify the prior duplication allele frequency of a pre-specified region used in --validate operation (this frequency can be estimated from CNV calls by --test operation)</text> </comment>"
                    }, 
                    "backfreq": {
                        "prompt": "Background CNV probability for any loci (backfreq)", 
                        "type": {
                            "datatype_class": "Float"
                        }, 
                        "precond": {
                            "perl": "not $delfreq and not $dupfreq ", 
                            "python": "not delfreq and not dupfreq"
                        }, 
                        "default_value": [
                            "0.0001"
                        ], 
                        "format": {
                            "perl": "(defined $value) ? \"--backfreq $value\" : \"\"", 
                            "python": "( \"\" , \" --backfreq \" + str(value) )[ value is not None ]"
                        }, 
                        "ctrl": {
                            "perl": " 0.5", 
                            "python": " 0.5"
                        }, 
                        "comment": "<text lang=\"en\">Background CNV probability for any loci, with default value as 0.0001. This argument is useful in validation calling. When -delfreq/-dupfreq is not specified, the background frequency is used to calculate the prior probability of different copy number states.</text> </comment>"
                    }, 
                    "candlist": {
                        "prompt": "A file containing all candidate CNV regions to be validated (candlist)", 
                        "type": {
                            "datatype_class": "CandidateRegion", 
                            "datatype_superclass": "AbstractText"
                        }, 
                        "precond": {
                            "perl": "not $startsnp and not $endsnp and not $delfreq and not $dupfreq", 
                            "python": "not startsnp and not endsnp and not delfreq and not dupfreq"
                        }, 
                        "format": {
                            "perl": "(defined $value) ? \"--candlist $value \" : \"\"", 
                            "python": "( \"\" , \" --candlist \" + str(value) )[ value is not None]"
                        }
                    }
                }
            }, 
            "cctestCalling": {
                "name": "cctestCalling", 
                "precond": {
                    "perl": "$rawcnv eq '--cctest'", 
                    "python": "rawcnv == '--cctest'"
                }, 
                "parameters": {
                    "phenofile": {
                        "ismandatory": true, 
                        "prompt": "A file containing phenotype information for each input file (phenofile)", 
                        "type": {
                            "datatype_class": "Phenotype", 
                            "datatype_superclass": "AbstractText"
                        }, 
                        "precond": {
                            "perl": "$rawcnv eq '--cctest'", 
                            "python": "rawcnv == '--cctest'"
                        }, 
                        "format": {
                            "perl": "(defined $value) ? \"--phenofile $value \" : \"\"", 
                            "python": "( \"\" , \" --phenofile \" + str(value) )[ value is not None]"
                        }, 
                        "comment": "<text lang=\"en\">A file containing phenotype informatoin for each individual, so that --cctest can be used to compare the frequency between cases and controls. Each line has two tab-delimited fields: file name and the phenotype. By default, \"control\" means control subjects, and other words means cases; however, the user can use --control_label argument to change the phenotype label for controls. </text> </comment>"
                    }, 
                    "control_label": {
                        "prompt": "The phenotype label for control subjects in the phenotype file (control_label)", 
                        "type": {
                            "datatype_class": "String"
                        }, 
                        "format": {
                            "perl": "(defined $value) ? \"--control_label $value \" : \"\"", 
                            "python": "( \"\" , \" --control_label \" + str(value) )[ value is not None ]"
                        }, 
                        "comment": "<text lang=\"en\">Specify the text label for control subjects in the phenotype file specified by the --phenofile argument. Normally the \"control\" is used to specify controls, and all other individuals are treated as cases. However, some times users may use 1 to denote controls and 2 to denote cases; in such situations the \"--control_label 1\" should be used for the --cctest operation.</text> </comment>"
                    }, 
                    "onesided": {
                        "prompt": "Performed one-sided test (onesided)", 
                        "type": {
                            "datatype_class": "Boolean"
                        }, 
                        "default_value": [
                            "0"
                        ], 
                        "format": {
                            "perl": "($value) ? \"--onesided\" : \"\"", 
                            "python": "( \"\" , \" --onesided \" )[ value ]"
                        }
                    }, 
                    "type_filter": {
                        "prompt": "Used together to specify types of CNVs to be tested (type_filter)", 
                        "type": {
                            "datatype_class": "Choice"
                        }, 
                        "default_value": [
                            "null"
                        ], 
                        "authorized_values": [
                            {
                                "value": "null", 
                                "label": "Both duplications and deletions"
                            }, 
                            {
                                "value": "dup", 
                                "label": "Duplications"
                            }, 
                            {
                                "value": "del", 
                                "label": "Deletions"
                            }
                        ], 
                        "format": {
                            "perl": "(defined $value  and $value ne $vdef) ? \"--type_filter $value \" : \"\"", 
                            "python": "( \"\" , \" --type_filter \" + str(value) )[ value is not None and value !=vdef ]"
                        }, 
                        "comment": "<text lang=\"en\">Specify the particular types of CNVs to be used in the --cctest operation. By default both duplications and deletions are treated as a single group of CNVs and be used to compare cases and controls. </text> </comment>"
                    }
                }
            }, 
            "miscOpt": {
                "name": "miscOpt", 
                "parameters": {
                    "fmprior": {
                        "prompt": "Prior belief on CN state for regions with CNV calls. Six numbers separated by a comma (fmprior)", 
                        "type": {
                            "datatype_class": "String"
                        }, 
                        "precond": {
                            "perl": "$rawcnv eq '--trio' or  $rawcnv eq '--quartet'", 
                            "python": "rawcnv =='--trio' or rawcnv =='--quartet'"
                        }, 
                        "format": {
                            "perl": "(defined $value) ? \"--fmprior $value \" : \"\"", 
                            "python": "( \"\" , \" --fmprior \" + str(value) )[ value is not None ]"
                        }, 
                        "ctrl": {
                            "perl": "$value ~= /\\d+(,\\d+){5}/", 
                            "python": "len(value.split(',')) == 6 "
                        }, 
                        "comment": "<text lang=\"en\">The prior probability of 6 hidden states a given CNV call in father or mother. This is used for joint calling of trios or quartets. It is specified as six numbers separated by a comma that sum up to 1. The empirically derived default values actually work well: trio, quartet.</text> </comment>"
                    }, 
                    "denovo_rate": {
                        "prompt": "Prior belief on genome-wide de novo event rate (denovo_rate)", 
                        "type": {
                            "datatype_class": "Float"
                        }, 
                        "precond": {
                            "perl": "$rawcnv eq '--trio' or  $rawcnv eq '--quartet'", 
                            "python": "rawcnv =='--trio' or rawcnv =='--quartet'"
                        }, 
                        "default_value": [
                            "0.0001"
                        ], 
                        "format": {
                            "perl": "(defined $value  and $value != $vdef) ? \"--denovo_rate $value\" : \"\"", 
                            "python": "( \"\" , \" --denovo_rate \" + str(value) )[ value is not None and value != vdef]"
                        }, 
                        "comment": "<text lang=\"en\">Specify the probability that a given CNV is a de novo event for family-based CNV calling. The default is 0.0001. trio, quartet</text> </comment>"
                    }, 
                    "medianadjust": {
                        "prompt": "Adjust genome-wide LRR such that median equal 0 (nomedianadjust)", 
                        "type": {
                            "datatype_class": "Boolean"
                        }, 
                        "precond": {
                            "perl": "$type eq '--test' or $rawcnv eq '--trio' or $rawcnv eq '--quartet' or $type eq '--joint' or  $type eq '--validate'", 
                            "python": "type =='--test' or rawcnv =='--trio' or rawcnv =='--quartet' or type =='--joint' or type =='--validate'"
                        }, 
                        "default_value": [
                            "1"
                        ], 
                        "format": {
                            "perl": "(not $value) ? \"--nomedianadjust\" : \"\"", 
                            "python": "( \"\" , \" --nomedianadjust \" )[ not value ]"
                        }, 
                        "comment": "<text lang=\"en\">This option is turned on by default. It adjust the log R Ratio values of the entire genome by a constant so that the median is zero: test, trio, quartet, joint, validate. </text> </comment>"
                    }, 
                    "bafadjust": {
                        "prompt": "Adjust genome-wide BAF such that median equal 0.5 (nobafadjust)", 
                        "type": {
                            "datatype_class": "Boolean"
                        }, 
                        "precond": {
                            "perl": "$type eq '--test' or $rawcnv eq '--trio' or $rawcnv eq '--quartet' or  $type eq '--joint' or  $type eq '--validate'", 
                            "python": "type =='--test' or rawcnv =='--trio' or rawcnv =='--quartet' or type =='--joint' or type =='--validate'"
                        }, 
                        "default_value": [
                            "1"
                        ], 
                        "format": {
                            "perl": "(not $value) ? \"--nobafadjust\" : \"\"", 
                            "python": "( \"\" , \" --nobafadjust \" )[ not value ]"
                        }, 
                        "comment": "<text lang=\"en\">This option is turned ON by default (new July 2008): it adjust the BAF values genome-wide such that the median value is 0.5.</text> </comment>"
                    }, 
                    "sdadjust": {
                        "prompt": "Adjust SD of hidden Markov model based on input signal (nosdadjust)", 
                        "type": {
                            "datatype_class": "Boolean"
                        }, 
                        "precond": {
                            "perl": "$type eq '--test' or $rawcnv eq '--trio' or $rawcnv eq '--quartet' or $type eq '--joint' or  $type eq '--validate'", 
                            "python": "type =='--test' or rawcnv =='--trio' or rawcnv =='--quartet' or type =='--joint' or type =='--validate'"
                        }, 
                        "default_value": [
                            "1"
                        ], 
                        "format": {
                            "perl": "(not $value) ? \"--nosdadjust\" : \"\"", 
                            "python": "( \"\" , \" --nosdadjust \" )[ not value ]"
                        }, 
                        "comment": "<text lang=\"en\">This option is turned ON by default: it adjust the SD values in HMM model such that the model fits the signal quality of the testing sample to reduce false positive calls</text> </comment>"
                    }, 
                    "flush": {
                        "prompt": "Flush input/output buffer (noflush)", 
                        "type": {
                            "datatype_class": "Boolean"
                        }, 
                        "default_value": [
                            "1"
                        ], 
                        "format": {
                            "perl": "(not $value) ? \"--noflush\" : \"\"", 
                            "python": "( \"\" , \" --noflush \" )[ not value ]"
                        }, 
                        "comment": "<text lang=\"en\">This argument is turned ON by default. It requires the input/output buffer to flush immediately (that is, no input/output is buffered). When PennCNV is running remotely (for example, through a SSH connection) or when the output is redirected, this argument cause the program to report progress in real-time. When running PennCNV in parallel with many processes accessing disks simultaneously, this option should be turned off to decrease system overhead. </text> </comment>"
                    }
                }
            }, 
            "outfile_name": {
                "ishidden": true, 
                "prompt": "Outfile for detect_cnv and Input file for visualize_cnv", 
                "type": {
                    "datatype_class": "Filename"
                }, 
                "precond": {
                    "perl": "($type is not None or $rawcnv is not None) and $type ne '--test'", 
                    "python": "(type is not None or rawcnv is not None) and type != '--test'"
                }, 
                "format": {
                    "perl": "\" --out detect_cnv.out \"", 
                    "python": "\" --out detect_cnv.out \""
                }
            }
        }
    }, 
    "outputs": {
        "parameters": {
            "output_split_file": {
                "isout": true, 
                "ishidden": true, 
                "prompt": "Split files", 
                "type": {
                    "datatype_class": "Split", 
                    "datatype_superclass": "AbstractText"
                }, 
                "precond": {
                    "perl": "defined $infile", 
                    "python": "infile is not None"
                }, 
                "filenames": {
                    "perl": "\"$infile.*\"", 
                    "python": "infile + \".*\""
                }
            }, 
            "analyse": {
                "name": "analyse", 
                "parameters": {
                    "output_cnv_file": {
                        "isout": true, 
                        "prompt": "CNV file", 
                        "type": {
                            "datatype_class": "Cnv", 
                            "datatype_superclass": "AbstractText"
                        }, 
                        "precond": {
                            "perl": "$type eq '--test' and $infile", 
                            "python": "type == '--test' and infile"
                        }, 
                        "filenames": {
                            "perl": "\"$infile_rawcnv\"", 
                            "python": "infile + \"_rawcnv\""
                        }
                    }
                }
            }, 
            "cnvoutput": {
                "name": "cnvoutput", 
                "parameters": {
                    "bed_cnv_file": {
                        "isout": true, 
                        "prompt": "CNV calls file", 
                        "type": {
                            "datatype_class": "Cnv", 
                            "datatype_superclass": "AbstractText"
                        }, 
                        "precond": {
                            "perl": "$type eq '--test' and $infile and $outputformat ne 'output'", 
                            "python": "type == '--test' and infile and outputformat != 'output'"
                        }, 
                        "filenames": {
                            "perl": "\"$infile.$outputformatcnv\"", 
                            "python": "infile + \"_\" + outputformat + \"cnv\""
                        }
                    }, 
                    "bed_file": {
                        "isout": true, 
                        "prompt": "Output file", 
                        "type": {
                            "datatype_class": "Cnv", 
                            "datatype_superclass": "AbstractText"
                        }, 
                        "precond": {
                            "perl": "($type is not None or $rawcnv is not None) and $type ne '--test' and $outputformat ne 'output'", 
                            "python": "(type is not None or rawcnv is not None) and type != '--test' and outputformat != 'output'"
                        }, 
                        "filenames": {
                            "perl": "\"$infile.$outputformat\"", 
                            "python": "infile + \"_\" + outputformat"
                        }
                    }
                }
            }, 
            "output_file": {
                "isstdout": true, 
                "prompt": "Output file", 
                "type": {
                    "datatype_class": "Cnv", 
                    "datatype_superclass": "AbstractText"
                }, 
                "precond": {
                    "perl": "$type ne '--test'", 
                    "python": "type != '--test'"
                }, 
                "filenames": {
                    "perl": "\"detect_cnv.out\"", 
                    "python": "\"detect_cnv.out\""
                }
            }
        }
    }, 
    "comment": "<text lang=\"en\">Divide-and-Conquer Multiple Sequence Alignment (DCA) is a program for producing fast, high quality simultaneous multiple sequence alignments of amino acid, RNA, or DNA sequences. The program is based on the DCA algorithm, a heuristic approach to sum-of-pairs (SP) optimal alignment that has been developed at the FSPM over the years 1995-97.</text> </comment>"
}